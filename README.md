# card-table-in-c
I'll be challenging myself to make a meaningful commit to a project everyday for November. In this project, I'm going to recreate every card game I can think of in C because that's what I'm learning right now.

Nov 1: Today, I made the card_table.c file, the main function, and three other functions. The program greets the user and asks them what game they want to play. It will loop until the user inputs a valid option. Currently, War is the only valid option. Then, it creates a deck of cards and prints it. The value of the cards is working perfectly, but I couldn't get the suits working yet (the code compiles fine; the suits are just random characters right now). I designed the deck as a 52 x 2 matrix, where deck[card number][0] is the value of the card, and deck[card number][1] is the suit of the card. This is the only way I could think of doing this with my current C knowlege. My goals for tomorrow are to get the suits working, at least get a good start on War, commit more than once, and leave more comments inside the code.   

Nov 2: Pretty solid day today. I completed all of my goals from yesterday. The suits are working great (I had to replace the characters inside the arrays for just 0, 1, 2, and 3, which represent hearts, diamonds, clubs, and spades respectively). I committed more than once, making sure that each time I did commit, the code was good and at least compiled. I added the shuffle_deck function, which shuffles the deck array and the split_deck function, which splits the shuffled deck into two hands, one for the player, and one for the opponent. I got a pretty good start to the war game; currently, it just compares each card in the same position in the 26 card hands and will give a win to whichever hand has the highest value card. Right now, it doesn't go beyond that. At the end, it tells you which player won. At this time, it can't handle ties, so it just gives the win to the opponent. I also added several more good comments explaining the logic of some functions and overall making the code more readable. My goal for tomorrow is to finish or at least get close to finishing war. 

Nov 3: Unfortunately, I did not have much time to work on this project today. However, I still got some stuff done. I got a good start on the war game; I added helper functions that will cycle through each player's hand, so the game can include the part where if you win, you get both the cards placed in that round. I changed the split_deck function, and now it will fill every spot in the 52 spot hand that doesn't get filled with a card with -1. The move_cards_up_in_hand function loops through every spot in a given hand except the last and sets each spot to the value of the spot that is directly after it. The last spot is just set to -1. This simulates removing the top card of a set of cards, where the second card will become the first, the third card will become the second, and so on. The add_cards_to_hand function takes in a hand of cards and another 2D array of cards ([2][2]), which represents the two cards that were placed down in a round of war and will be given to the winner of the round. The function loops through all of the cards in the given hand, and when it sees the first -1, it will repace that with the first card passed in the function, and it will do the same for the second -1 it finds. This represents taking the cards you won when you win a round and putting them at the bottom of your hand. Right now, the main game while loop is looping infinitely, so my main goal for tomorrow is to just do some debugging, find out why it's an infinite loop, and fix it. Hopefully, I can also implement ties tomorrow.    

Nov 4: Today, I finished up the war game. I added the check_amount_of_cards function, which takes in a hand of cards, loops through them until it finds a spot in the array filled with -1, representing the spot after the last card in the hand. When it finds that position, it returns that position because that position also represents the total amount of cards in the given hand. That is because every filled spot is always in the front due to the main loop always moving cards to the front with the move_cards_up_in_hand function. I used this function to fix the infinite loop problem. I also added the war_tie function, which has three parts. The first part exists to initialize the prize_cards matrix, representing the three cards each player places down when their cards tie in the normal round. It loops three times; each time it loops, it checks if each hand has more than one card, and if it does, it adds the first card from the hand to prize_cards. Each time the more-than-one-card check fails, a variable, cards_not_filled, is incremented. The second part of the function loops the amount of times cards_not_filled is equal to and fills the rest of the [6][2] prize_cards matrix with -1. The third part of the function checks to see what the outcome of the war is; if the player or opponent won, it returns that fact as an integer. If they tie, (again) the function just calls itself again, which represents a double war or double tie in the real game. I also moved everything associated with war to its own function called war, with the main function calling it. This makes the main function much cleaner. Now, the main function is a loop that will ask the user what game they want to play forever until they quit by entering 0. I also added max_turns. When war is chosen, the main function will ask what the max turn limit should be. When they user answers, it inputs it into the war function along with the deck to be used, and the game starts. If the game makes it to the max turn limit, it just ends, and whoever has the most wins overall will win the game. My goal for tomorrow is to make war's prints more aesthetically pleasing and helpful. 

Nov 5: Today, I started by adding manual mode. Manual mode allows the user to go through each war round at a time. After the user chooses the turn limit, the user is prompted to choose if they want automatic mode or manual mode. If the user types 1, the game plays as it previously had, scrolling through all of the rounds until the game ends. If the user selects 2, they activate the manual mode. The game will start normally. At the end of the war loop, there is a if statement to determine if the user is in manual mode. If yes, it will stop/freeze the program with a scanf, and the user will have the ability to type 1 to continue on to the next round. The user can also choose to type 2 to exit manual mode. This just finishes the rest of the game in automatic mode. I also added a turn counter. At the start of each round, the turn gets printed, so the user knows exactly what round they're on. Furthermore, the program also now counts how many cards each player has. Using the check_amount_of_cards function from yesterday, the program counts and prints each card count at the end of each round. This probably should have happened earlier, but I removed the two print_deck function calls at the beginning because they're not useful anymore. The print_deck function will probably only be used for troubleshooting from now on. Unfortunately, I also found a big bug. The war_tie function never actually adds the prize cards the the winner's hand, and there are a couple of other logical errors that happen when there is less than four cards in either player's hand. I think I rushed that function yesterday. I got a good start on troubleshooting that, and I thought I found a solution to the first problem, but now I've noticed that now sometimes cards are being set to zero somehow, so I need to look into that. In trying to find the solution, I made the add_cards_to_hand function more flexible, and it can now take in [any size][2] arrays. This will let more add the prize cards more easily. I ran out of time to troubleshoot more today, but my goals for tomorrow are to fix that function, fully complete the aesthetics of war, and possible start a new card game that the user can choose from.      

Nov 6: Today, I worked to fix the war bug. I mostly rewrote the war_tie function. Now, after all of the variable declarations, it checks if the player or the opponent has less than five cards. If the player or opponent has less than five cards, there is another if statement to determine which player has less cards, and the amount of cards the player with less cards has gets assigned to the variable lowest_cards. Then, the amount of the variable prizes gets changed from its default value of eight to (lowest_cards - 1) * 2. After that, the program loops prizes times, and during the first half of the loop, the player's cards get moved into the prize_cards, and during the second half of the loop, the opponent's cards get moved into prize_cards. Then the only thing left to do is to compare the next cards in each player's hand. If the player won, the prize_cards are added into their hand and the fact they won is returned. If the opponent won, the prize_cards are added into their hand and the fact they won is returned. This new logic got rid of all of the logic errors that had to do with the function. I also fixed the grammar of the ending statment, so if a player has 0 cards left, it prints that instead of saying they have 0 card left. Also, I realized that I never actually made the war_tie function print anything, so I fixed that, and now when a tie happens, the user will have a much easier time understanding what's going on in the round. Now, I am completely done with war. My goal for tomorrow is to get a good start on a new card game. I need to think of a simple enough game for this because I want to hopefully have something to show off tomorrow, even if it's just a small demo.   

Nov 7: Today, I stared coding my new memory card game. Most of my time I spent on this today was spent thinking of ideas for the new game, and how I would implement them. First, I added the memory function and the memory_print function. The memory function is supposed to be the new main function for the memory game, like how the war functions handles everything to do with the war game. The memory function first takes in a deck of cards and returns void. At the start, it just prints a greeting to the user. Next, it declares a new array, cards_to_flip, and I just have it initailize as {5, 0} right now as a placeholder. In the future, user input will decide what it is initialized to. Lastly, the memory function calls the memory_print function. The memory_print function is supposed to print the memory board od cards, so the user can see all of the cards (face up or down) at once. The memory_print function takes in two parameters: the deck of cards and a 1D integer array called card_to_flip. It returns void. The first thing it has is a nested for loop that will loop for twenty five times total (each for loops five times). Then, it checks if the card_to_flip matches the card in the deck in the current loop. If it does, it prints that card. If it doesn't, it just prints "[]". After each five loops, a newline is printed. Right now, the code doesn't work that well, but it is a good skeleton for the future program. My goals for tomorrow are to at least get enough done to have a working demo.

Nov 8: Today, I did achieve my goal, and I have a small demo working. First, I added memory as an option for the user to select in the main loop. Now, the main loop has a lot of unnecessary stuff in it, so I'll have to make it perfect sometime. But for now, it does the same thing as before. I added the memory option in the the print statement that shows the user all of the options they can choose. Then, when the user makes a choice, it is stored in the choice variable, and there is a switch statement to set game_selected to 2. That is where the redundancy is that I'll fix later. Next, the first deck is declared, initialized with create_deck, shuffled with shuffle_deck, and there is a if statement to decide which game was chosen. Once it gets to memory, it calls the memory function. Today I also tried a lot of different approaches with the memory_print function. At first, the card_to_flip was the actual card value and card suit. I decided against this because when I thought more into it, it just didn't make sense. I decided to do a approach where the card_to_flip is the card's row and the card's column. This just makes a lot more sense when you think about it. Now when the function loops twenty five times, it checks if the i of the first nested for loop matches the card_to_flip[0] and if the j of the second nested for loop matches the card_to_flip[1]. If it does, it prints the card, and if it doens't, it prins []. I also finally added the main game loop for the memory function. Right now, it loops two times, and each time it loops, it asks the user what row of card do they want to flip. It stores the row in the row variable and asks the user what column of card they want to flip, and it stores that into the col variable. Then it puts all of that info into the memory_print function and prints the new memory grid with the user-chose flipped card. The memory_print function also can take two card_to_flip's, so now the user can flip two at a time, and that's why the main memory game loop loops twice at a time. My goal for tomorrow is to have the memory game have a win/lose state. I also want to print the row and column numbers when printing the grid, so it can be more user-friendly.

Nov 9: Today, I focused on being user-friendly. First, I simplied the user prompts to now be straight to the point. Now it prompts the user with "Card #[1 or 2] row?" and "Card #[1 or 2] column?" Also, yesterday I guess I never noticed that card_to_flip2 didn't work properly. There just wasn't an if statement to print it in the memory_print function. I fixed that by adding the if statement, and now it works perfectly. I also achieved my goal from yesterday of printing the row and column numbers. This was a bit of a challenge for the nested for loops, but I was able to figure it out. Instead of looping five times, the outer for loop (i) now loops six times, but there is now a if statement in inside the nest checking if it's the first time i has looped. If yes, it only prints the column numbers. If no, it just print the memory grid as normal. The row numbers were slightly simpler to implement. Inside the outer for loop and outside the inner for loop (it's before the inner for loop) is a if statement that checks if i is greater than 0. If it is, it prints the row number. Next, also to be more user friendly, I decided to change the row and column numbers to start at one instead of zero. I feel like starting at one is easier to visualize, and it's more convenient when you're typing numbers on a keyboard. Last but not least, I added and implemented the create_memory_deck function. I decided that a normal deck of cards wouldn't cut it for this game, so I need to make a custom deck of cards. The create_memory_deck takes in a [25][2] integer matrix, returns void, and is very similar to the create_deck function. It has a set of nested for loops that work to initialize the deck matrix. Since the memory grid has an odd number of spaces, at the end of the create_memory function, there is a couple of lines that manually initialize the last element of the matrix. The only difference is the actual deck. The memory deck is just 1-12 (except the last element) and 1 and 2 as the "suits." Because the create_deck and create_memory_deck functions are so similar, I think it would be a good idea to just merge them in the future. Currently, the create_memory_deck function is implemented just as a demo because it doesn't shuffle or print yet. If I were to merge the two functions, I would also need to make the shuffle_deck and print_deck functions compatible with the new memory deck type. That's exactly my goal for tomorrow: I want to merge these two functions together and make all of the related functions work with memory decks.

Nov 10: Today, I unfortunately did not have much time to work on this. I added the print_memory_deck function and shuffle_memory_deck function. These function are essentially copies of the normal deck versions, and it will make it easier to achieve yesterday's goal tomorrow to merge all of the functions. My goal for tomorrow is to just finish yesterday's goal, make up for lost time today, and possibly finish the entire memory game. 

Nov 11: Today, I did all of the function merges that I originally planned to do. First, I made the create_deck function compatible with memory decks. Now, instead of just having int new_deck[52][2] as its paramater, it has int new_deck[][2] and int is_normal_deck as its parameters. It still returns void. The first dimension of new_deck was made blank to make the function flexible with 52 or 25 card decks. The is_normal_deck variable is essentially a boolean that tells the program if the deck that is to be created is a normal 52 card deck or a 25 card deck. At the start of the function, it defines the suits array as normal, and now it also declares num_of_suits and num_of_unique_cards. Then, there is an if statement that initializes these variables based on if the deck to be created is a normal (52 card) deck. If the deck to be created is a memory deck, the last elements of the new_deck matrix are initalized here because 25 is not divisible by two. Then the function goes on almost identically to the original create_deck function, but all of the number specific operations were replaced by the num_of_suits and num_of_unique_cards variables, making the function fully able to support both deck types. After the create_deck function, I worked to make the shuffle_deck function compatible with both deck types. The parameter change for the shuffle_deck function is very similar to the create_deck function: instead of just having int deck[52][2] as its paramater, it has int new_deck[][2] and int is_normal_deck as its parameters. It also returns void. At the start of the function, the function declares num_of_cards_in_deck, and it initializes that variable based the value of is_normal_deck with an if statement. With num_of_cards_in_deck initialized to either 25 or 52, the copy_deck matrix is declared as copy_deck[num_of_cards_in_deck][2]. Then the entire deck is looped through using nested for loops, and the function initializes every element of copy_deck to be the same as the same given element in deck. Then the deck matrix is filled completely with -1 using the same nested for loops. The rest of the function is very similar to the original shuffle_deck. Next, the function loops through the deck, randomly selecting a spot in deck, and if deck[the random number][0] == -1, that element of the deck is initialized to the nth (the number of iterations of the current loop) element of copy_deck. I also made the print_deck function compatible with the memory decks. The print_deck function now has the exact same parameters as create_deck and shuffle_deck, and print_deck also returns void. Then, print_deck does the exact same thing shuffle_deck did: it declared num_of_cards_in_deck and initialized it based on if it's a normal 52 deck or not. I already made the print_deck function for the most part compatible with different sizes of decks a few days ago, so it was easier than the others to add the memory deck to. Other than what was mentioned above, all I had to do was add a check of it's not a normal deck, and if it's not, instead of the normal format for printing decks, it uses this format: "Card #[number of card]: [value of card] ([suit] of 2)." I also added a check that makes the 2 into a one if the card value is 13. After doing all of these functions, I deleted the memory deck specific, now useless functions and their prototypes. I think it's reasonable to make tomorrow's goal to finish the entire memory game since I now have a big chunk of it done.

Nov 12: Today, I worked on the memory game some more. I forgot to mention this is the yesterday, but the last thing I did yesterday was add the initialize_matches_array function. It is a very simple function; it only has one parameter, an 25-element integer array called matches, and it returns void. The only thing the function really does is it loops through all 25 elements of the matches array and sets each one of them to zero. The purpose of this function is pretty self-explanatory: it is used to intialize the matches array away from the memory function. I haven't done much with the matches array quite yet, but I added it as a parameter to the memory_print function. The purpose of the array is to store the numbers (or positions; I haven't decided yet) that the user has already matches, so when the memory_print function prints the memory board, they stay on instead of disappearing after two selections like they do right now. The part that I spent most of my time today on is the part where the program decides if the two numbers the user chose have the same values, and therefore are a match. To try to achieve this, I added the compare_two_memory_positions function. This function takes in three parameters: the deck matrix, an array of card1's position ({row, col}), and an array of card2's position. The function returns 1 or 2 based on if the comparison is successful. First, the fuction initializes four variables holding the row and columns of each card. These are decremented once during the initialization to match the real rows and columns (starting at 0) instead of the user-friendly ones (starting at one). Then two variables containing each card's value are initialized using the deck and the rows and columns. If card1's value is equal to card2's value, the function returns 1, and if card1's value does not equal card2's value, the function returns 0. This means the function essentially returns a boolean value. To implement the function, I added an if statement in the memory loop after the user has selected a pair of cards, and I made the function run inside the if conditional. So, if the compare_two_memory_positions function returns 1, the inside of the if statement should happen, and if it returns 0, it should skip the if statement. The inside of the if statement for now just has a simple print that tells the user that they got a match. Here's where I ran into some trouble. When doing some testing, if I selected two cards in the first column, the program said they were a match no matter what their values were. After doing some debugging, I still haven't figured out why that is. The other columns seem to work just fine. Also, I found that if you select any card in the fifth row, it will print a garbage value. I have no idea if the card itself is messed up or just the print. My goal for tomorrow is to get to the bottom of those bugs, fix them, and continue working on the memory game.

Nov 13: Today, unfortunately, I was very busy, so I didn't get much done. I changed the compare_two_memory_positions function to return the cards' value if the cards matched instead of 1. It still returns 0 if there is no match. In the memory function, I took the compare_two_memory_positions function call out of the if statement, and instead I call it the line before, so the return can be used more than once. I called the variable that receives the function's return value match_card_value. I put the match_card_value variable in the if statement conditional, so effectively nothing changed there. But now, inside the if statement, after the print telling the user they got a match, array match_card_value of the matches array is set to 1. In the future, this will help save the matches that the user has already achieved, so they keep showing up despite not being one of the two cards the user just selected. Outside of the if statement, I made it so both elements of both of the card_to_flip arrays are reset to -1. My goal for tomorrow is to finally make some real progress on the game, and I hope to be able to devote more time to this project in general.

Nov 14: Today, I focused on fixing the bugs that I outlined two days ago. I put a lot of time into just doing trial and error on these bugs until it worked. I ended up adding and deleting several different types of print statements to help me debug. First the issue was that if the user selected a card on the fifth row, the program would print some garbage value instead of its real value. I figured out that this was because the difference betweent the real rows and columns and the user-friendly rows and columns. I didn't know exactly how to fix it, so after a while, I was able to fix it by (and this seems obvious now) subtracting one from i and j when calculating the index in the nested for loops. This would turn the user-friendly rows and columns into the array indexes because the user-friendly rows and columns start at 1 and go to 5, and the array indexes start at 0 and go to 4. When I tested this out, when I selected a card on the fifth row, it gave me its correct value. Then I realized there was another issue, which I later found out was caused by my solution to the first issue. The issue was that the program no longer identified matches when there was one. At this point, the program didn't do anything about matches, but it was supposed to tell the user that they got a match, and it wasn't doing that anymore. I honestly had zero clue on where to start on this issue; I didn't know how the matches could just stop working randomly. What eventually helped me was one of the print statements I added. I made it so instead of printing an empty board at the beginning of the game, it would print the completed board (I just replaced the print for the empty cards with the same logic from the print the cards_to_flip). This made me realize that the entire board was shifted right one; the first card of the deck was in the second spot on the memory grid, the second card of the deck was in the third spot on the memory grid, and so on. This meant the first spot of the memory grid was always 00, and the last card of the deck was never placed on the memory grid. This made me realize that I kind of got lucky with the earlier solution. After more trial and error, I found that in the nested for loops, only i needed to subtract 1, not j. This fixed the deck alignment issue and the matches not being identified issue. I also discovered that when calculating the two cards' value in the compare_two_memory_positions function, the rows and columns needed to be decremented because of the actual rows and user rows disconnect. This was only a minor bug; it wouldn't affected things until later. Last but not least, I decided to actually make the already-found matches stay on the screen. I was having trouble trying to visualize how to do this with the current matches array (a 25 element, one dimension array), so I changed the mates array to be a 5x5 matrix. This lets me make the matches into a standard rows and columns. I decided to just put the cards' value in their correct rows and columns when a match was found. This would make the matches matrix match the memory grid, and this made it easy to make a check in the memory_print function to make the already-found matches stay forever. After this, I commented out all of the debugging print statements, and I was able to play the full game with no bugs. For tomorrow, my goal is to put polish and finsihing touches into the memory game.

Nov 15: Today, I finished the memory game. I started by polishing the game a little bit. First, I made it so the user can't choose a card that's out of bounds. They also can't choose a card that has already been chosen or been matched. If the program deems the user's card choice to be invalid, it tells the user that, and prompts them to input a new one. Next, I finally decided to change the memory_print function so that it only prints the card's value, not its suit. The reason for this is if the card's value was two digits, then that combined with the card's suit would be three digits, and that would shift the only row of the grid over. I thought that would just confuse the user in later rounds, when more stuff is filled in, and since most of this game has been focused on being user-friendly, I decided to make that change. If the card's value is only one digit, the program checks for that, and it'll add a zero in front, so the print wouldn't be only one digit and cause the opposite problem. Then, I made the round print more noticeable by adding five dashes on either side of it and adding an extra new line above. I also wanted to make sure the memory grid printed after the second card flip, so I did that. However, I realized that this will print too much at once. It would print the memory grid for the second card, and then print the new round and its memory grid. Because of this, I wanted to add a sort of delay between rounds. I decided to just prompt the user to enter one if they wish to continue the game, and if they entered 1, the next round would print. I then realized that this could double as an opportunity to let the user quit the game without having to restart the program, so I also made it so if the user entered 0 instead of 1, they game would just quit then and there. I then wanted to finally add a way to win the game. I decided I needed to add a function to return a card's value given its position, so I could see if the user picked the last card, 13. I have a function that does something similar to that, the compare_two_memory_positions function, so I borrowed some code from it. I called the new function card_value_from_position. It essentially does the same thing as compare_two_memory_positions, but only with one card, and it always returns the card value. I then made the compare_two_memory_positions function use the card_value_from_position function to make itself simplier. In the pursuit of a win state, I also added the check_if_matches_is_filled function. The check_if_matches_is_filled function basically just loops through the matches matrix, and if there is exactly one spot empty (the spot for the card 13), it returns 1, and otherwise, it returns 0. In the part of the memory function where the user inputs the first card of a round, I added an if statement that checks if the card they just picked is the card 13, and if the matches matrix has one spot open. If both statements are true, the program prints the memory grid again, lets the user know how many rounds it took them to win, and returns back to the main card table loop. Now the memory game is completely finished. My goal for tomorrow is to start another card game. I also want to start spending more time on this every day because I want the card_table to be full of almost every card game I can think of by the end of the month. 

Nov 16: Today, I started a new game. I was brainstorming games that would be easyish to code, and I thought of Go Fish. I started by adding the go_fish function. It takes in a 52 card deck as its only parameter, and it returns void. Right when I created the go_fish function, I decided to add it to the main loop. I added an extra prompt, so the user knows Go Fish is an option, and they need to enter 3 to get go fish. I added case 3 in the switch statement, where game_selected is set to 3, type_of_deck is set to 1 (a normal 52 card deck), and amount_of_cards_in_deck is set to 52. Then a deck is created and shuffled, and if game_selected is equal to 3, the go_fish function is called with that deck as an argument. After defining the player and opponent's hands, I realized I would need some way of dealing 7 cards to each player. The function split_deck existed, but that function just splits the deck in two, with there being no way to decide how many cards each player got. Because of that, I decided to make a another function, deal_cards. The deal_cards function takes in a [52][2] deck matrix, a [52][2] new_hand matrix, and an integer, num_of_cards, telling the function how many cards to transfer from the deck to the new_hand. The function returns void. The function loops the amount of times equal to num_of_cards, and each time it loops, the first card of the deck becomes the ith card of the new_hand. Then the function calls the move_cards_up_in_hand function with the deck as its argument. After that, in a seperate for loop, the function fills the rest of the spaces in each hand with -1. Once the deal_cards function was done, I called it twice (one for each player) in the go_fish function. After that, when I tried printing the hands to test the deal_cards function, I encountered a problem. Every time I ran the program, the program just crashed. I couldn't figure out why that happened until I decided to try to fully initialize the hands before dealing cards to them. So, I created a new function, initialize_hand that just takes in a [52][2] new_hand matrix and returns void. The initialize_hand functions just loops through the new_hand matrix and sets every element to -1. Then, I modified the deal_cards function to only do the dealing cards part, and it will now call initialize_hand for the hand at the beginning of the function. This solution worked; the program no longer crashed. After that, I just created a simple game loop in the go_fish function, and I realized I needed to create a list of their cards to prompt the user for which card they'd like to ask the opponent for. To do that, I created a new function, print_hand_as_list, that takes in a [52][2] hand matrix and returns void. The print_hand_as_list function just loops 52 times, and if the ith element in hand isn't -1, it prints it with the formatting I wanted to properly prompt the user. After that function was done, I implemented it in the go_fish loop. My goal for tomorrow is to just keep working on go fish. 

Nov 17: Today, I kept working on go fish. First, I decided that I wanted to change how the print_hand_as_list function worked. I wanted to have it print just the card values the user could choose from in order. This turned out to be much harder than it sounded to me at the time. I pretty much rewrote the entire function. First, the print_hand_as_list function declares and initializes each element of the 13 element unique_cards array to -1. It also initializes the size_of_unique_cards variable to 0. Then it loops through the hand matrix; if the current card value in the hand isn't -1 (which means it is a valid card), it then loops through the unique cards array. By default the variable unique is set to 1, and if the current unique cards element is equal to the current hand card value, unique is set to 0. After the loop through unique_cards, the function checks if unique is set to 1. If it is, it loops through unique_cards again. In the loop, if the current element of unique_cards is -1, and this is the first time this loop that this has happened, that element of unique_cards is set to the current hand card value and the size_of_unique_cards is incremented. After all of those loops have finished, it sorts the unique_cards array in increasing order (other than the -1's, of course). At that point, I didn't have any type of sorting algorithim to work with, so I decided to code my own bubble sort function. The function is called bubble_sort and it takes in the array_to_sort array of any size and the size_of_array. It returns void. First, the bubble_sort function declares the copy_value variable. Then, uses nested for loops. The first loop is it looping size_of_array times (i). Then it loops size_of_array - 1 times (j). Inside the loops, there is a if statement to determine if the array_to_sort[j] is greater than the array_to_sort[j+1]. If it is, the copy_value is set to array_to_sort[j]. Then array_to_sort[j] is set to the array_to_sort[j+1]. Finally, array_to_sort[j+1] is set to the copy value. In the print_hand_as_list function, that's how the unique_cards array is sorted. Then, it loops size_of_unique_cards times, and each time it loops, it prints each value of new_hand in the formatting that I wanted. Now that the user prompt was perfect, I wanted to work on the actual go fish logic. To do that, I added the check_if_card_in_hand function. It takes in the [52][2] hand matrix, a card_value integer variable, and the cards_in_hand [3][2] matrix. It will return the amount of cards that the opponent has to give over to the player. First, I decided that I need to initialize the cards_in_hand matrix. To do this, I decided to make the initialize_hand function accept any length of matrix, so now I could call it at the beginning of the check_if_card_in_hand function to initialize cards_in_hand. Then the function loops through the hand matrix, and if the current hand card value is the same as card_value, that card gets added to the cards_in_hand matrix. My goal for tomorrow is to keep working on go fish.

Nov 18: Today, I didn't have much time to work on this because I was studying for an important exam. I did accomplish implemented the go fish action. Now, if the player requests a card value that the opponent doesn't not have, the program prints "Go Fish", and a new [1][2] matrix, card_to_add is initialized as one card: the card on top of the deck. Then, the add_cards_to_hand function is called, which will add the card contained in card_to_add to the end of the player's hand. After that, the move_cards_up_in_hand function is called to shift all of the cards in the deck up one position to fill the card that was just transfered to the player's hand. The goal for tomorrow is just to keep working on go fish.

Nov 19: Today, I didn't have much time to work on this because I was studying for the same important exam as yesterday. I did implement the opponents turn. Right now, the game functions as a pass and play game, where there is no single player, and the user is supposed to have a friend with them to play the game. So, the opponent's turn largely functions the same as the player's turn. Right now, the program consists of the block of code that does the player's turn then the block of code that does the opponent's turn. I put a for loop for now, but it doesn't actually save space in the code, and I feel like a loop of some kind could make all of that more consise. I couldn't think of how to do that today, but I'm sure I'll figure it out tomorrow. In the future, I want to be able to add a feature where the user can choose to play against a computer instead of playing against a friend or themselves. I also made the main game loop. Now there is a infinite while loop that will have go fish go on forever. Tomorrow I'll actually have time to work on this, and my goal is to almost complete go fish.
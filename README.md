# card-table-in-c
I'll be challenging myself to make a meaningful commit to a project everyday for November. In this project, I'm going to recreate every card game I can think of in C because that's what I'm learning right now.

Nov 1: Today, I made the card_table.c file, the main function, and three other functions. The program greets the user and asks them what game they want to play. It will loop until the user inputs a valid option. Currently, War is the only valid option. Then, it creates a deck of cards and prints it. The value of the cards is working perfectly, but I couldn't get the suits working yet (the code compiles fine; the suits are just random characters right now). I designed the deck as a 52 x 2 matrix, where deck[card number][0] is the value of the card, and deck[card number][1] is the suit of the card. This is the only way I could think of doing this with my current C knowlege. My goals for tomorrow are to get the suits working, at least get a good start on War, commit more than once, and leave more comments inside the code.   

Nov 2: Pretty solid day today. I completed all of my goals from yesterday. The suits are working great (I had to replace the characters inside the arrays for just 0, 1, 2, and 3, which represent hearts, diamonds, clubs, and spades respectively). I committed more than once, making sure that each time I did commit, the code was good and at least compiled. I added the shuffle_deck function, which shuffles the deck array and the split_deck function, which splits the shuffled deck into two hands, one for the player, and one for the opponent. I got a pretty good start to the war game; currently, it just compares each card in the same position in the 26 card hands and will give a win to whichever hand has the highest value card. Right now, it doesn't go beyond that. At the end, it tells you which player won. At this time, it can't handle ties, so it just gives the win to the opponent. I also added several more good comments explaining the logic of some functions and overall making the code more readable. My goal for tomorrow is to finish or at least get close to finishing war. 

Nov 3: Unfortunately, I did not have much time to work on this project today. However, I still got some stuff done. I got a good start on the war game; I added helper functions that will cycle through each player's hand, so the game can include the part where if you win, you get both the cards placed in that round. I changed the split_deck function, and now it will fill every spot in the 52 spot hand that doesn't get filled with a card with -1. The move_cards_up_in_hand function loops through every spot in a given hand except the last and sets each spot to the value of the spot that is directly after it. The last spot is just set to -1. This simulates removing the top card of a set of cards, where the second card will become the first, the third card will become the second, and so on. The add_cards_to_hand function takes in a hand of cards and another 2D array of cards ([2][2]), which represents the two cards that were placed down in a round of war and will be given to the winner of the round. The function loops through all of the cards in the given hand, and when it sees the first -1, it will repace that with the first card passed in the function, and it will do the same for the second -1 it finds. This represents taking the cards you won when you win a round and putting them at the bottom of your hand. Right now, the main game while loop is looping infinitely, so my main goal for tomorrow is to just do some debugging, find out why it's an infinite loop, and fix it. Hopefully, I can also implement ties tomorrow.    

Nov 4: Today, I finished up the war game. I added the check_amount_of_cards function, which takes in a hand of cards, loops through them until it finds a spot in the array filled with -1, representing the spot after the last card in the hand. When it finds that position, it returns that position because that position also represents the total amount of cards in the given hand. That is because every filled spot is always in the front due to the main loop always moving cards to the front with the move_cards_up_in_hand function. I used this function to fix the infinite loop problem. I also added the war_tie function, which has three parts. The first part exists to initialize the prize_cards matrix, representing the three cards each player places down when their cards tie in the normal round. It loops three times; each time it loops, it checks if each hand has more than one card, and if it does, it adds the first card from the hand to prize_cards. Each time the more-than-one-card check fails, a variable, cards_not_filled, is incremented. The second part of the function loops the amount of times cards_not_filled is equal to and fills the rest of the [6][2] prize_cards matrix with -1. The third part of the function checks to see what the outcome of the war is; if the player or opponent won, it returns that fact as an integer. If they tie, (again) the function just calls itself again, which represents a double war or double tie in the real game. I also moved everything associated with war to its own function called war, with the main function calling it. This makes the main function much cleaner. Now, the main function is a loop that will ask the user what game they want to play forever until they quit by entering 0. I also added max_turns. When war is chosen, the main function will ask what the max turn limit should be. When they user answers, it inputs it into the war function along with the deck to be used, and the game starts. If the game makes it to the max turn limit, it just ends, and whoever has the most wins overall will win the game. My goal for tomorrow is to make war's prints more aesthetically pleasing and helpful. 

Nov 5: Today, I started by adding manual mode. Manual mode allows the user to go through each war round at a time. After the user chooses the turn limit, the user is prompted to choose if they want automatic mode or manual mode. If the user types 1, the game plays as it previously had, scrolling through all of the rounds until the game ends. If the user selects 2, they activate the manual mode. The game will start normally. At the end of the war loop, there is a if statement to determine if the user is in manual mode. If yes, it will stop/freeze the program with a scanf, and the user will have the ability to type 1 to continue on to the next round. The user can also choose to type 2 to exit manual mode. This just finishes the rest of the game in automatic mode. I also added a turn counter. At the start of each round, the turn gets printed, so the user knows exactly what round they're on. Furthermore, the program also now counts how many cards each player has. Using the check_amount_of_cards function from yesterday, the program counts and prints each card count at the end of each round. This probably should have happened earlier, but I removed the two print_deck function calls at the beginning because they're not useful anymore. The print_deck function will probably only be used for troubleshooting from now on. Unfortunately, I also found a big bug. The war_tie function never actually adds the prize cards the the winner's hand, and there are a couple of other logical errors that happen when there is less than four cards in either player's hand. I think I rushed that function yesterday. I got a good start on troubleshooting that, and I thought I found a solution to the first problem, but now I've noticed that now sometimes cards are being set to zero somehow, so I need to look into that. In trying to find the solution, I made the add_cards_to_hand function more flexible, and it can now take in [any size][2] arrays. This will let more add the prize cards more easily. I ran out of time to troubleshoot more today, but my goals for tomorrow are to fix that function, fully complete the aesthetics of war, and possible start a new card game that the user can choose from.      

Nov 6: Today, I worked to fix the war bug. I mostly rewrote the war_tie function. Now, after all of the variable declarations, it checks if the player or the opponent has less than five cards. If the player or opponent has less than five cards, there is another if statement to determine which player has less cards, and the amount of cards the player with less cards has gets assigned to the variable lowest_cards. Then, the amount of the variable prizes gets changed from its default value of eight to (lowest_cards - 1) * 2. After that, the program loops prizes times, and during the first half of the loop, the player's cards get moved into the prize_cards, and during the second half of the loop, the opponent's cards get moved into prize_cards. Then the only thing left to do is to compare the next cards in each player's hand. If the player won, the prize_cards are added into their hand and the fact they won is returned. If the opponent won, the prize_cards are added into their hand and the fact they won is returned. This new logic got rid of all of the logic errors that had to do with the function. I also fixed the grammar of the ending statment, so if a player has 0 cards left, it prints that instead of saying they have 0 card left. Also, I realized that I never actually made the war_tie function print anything, so I fixed that, and now when a tie happens, the user will have a much easier time understanding what's going on in the round. Now, I am completely done with war. My goal for tomorrow is to get a good start on a new card game. I need to think of a simple enough game for this because I want to hopefully have something to show off tomorrow, even if it's just a small demo.   

Nov 7: Today, I stared coding my new memory card game. Most of my time I spent on this today was spent thinking of ideas for the new game, and how I would implement them. First, I added the memory function and the memory_print function. The memory function is supposed to be the new main function for the memory game, like how the war functions handles everything to do with the war game. The memory function first takes in a deck of cards and returns void. At the start, it just prints a greeting to the user. Next, it declares a new array, cards_to_flip, and I just have it initailize as {5, 0} right now as a placeholder. In the future, user input will decide what it is initialized to. Lastly, the memory function calls the memory_print function. The memory_print function is supposed to print the memory board od cards, so the user can see all of the cards (face up or down) at once. The memory_print function takes in two parameters: the deck of cards and a 1D integer array called card_to_flip. It returns void. The first thing it has is a nested for loop that will loop for twenty five times total (each for loops five times). Then, it checks if the card_to_flip matches the card in the deck in the current loop. If it does, it prints that card. If it doesn't, it just prints "[]". After each five loops, a newline is printed. Right now, the code doesn't work that well, but it is a good skeleton for the future program. My goals for tomorrow are to at least get enough done to have a working demo.

Nov 8: Today, I did achieve my goal, and I have a small demo working. First, I added memory as an option for the user to select in the main loop. Now, the main loop has a lot of unnecessary stuff in it, so I'll have to make it perfect sometime. But for now, it does the same thing as before. I added the memory option in the the print statement that shows the user all of the options they can choose. Then, when the user makes a choice, it is stored in the choice variable, and there is a switch statement to set game_selected to 2. That is where the redundancy is that I'll fix later. Next, the first deck is declared, initialized with create_deck, shuffled with shuffle_deck, and there is a if statement to decide which game was chosen. Once it gets to memory, it calls the memory function. Today I also tried a lot of different approaches with the memory_print function. At first, the card_to_flip was the actual card value and card suit. I decided against this because when I thought more into it, it just didn't make sense. I decided to do a approach where the card_to_flip is the card's row and the card's column. This just makes a lot more sense when you think about it. Now when the function loops twenty five times, it checks if the i of the first nested for loop matches the card_to_flip[0] and if the j of the second nested for loop matches the card_to_flip[1]. If it does, it prints the card, and if it doens't, it prins []. I also finally added the main game loop for the memory function. Right now, it loops two times, and each time it loops, it asks the user what row of card do they want to flip. It stores the row in the row variable and asks the user what column of card they want to flip, and it stores that into the col variable. Then it puts all of that info into the memory_print function and prints the new memory grid with the user-chose flipped card. The memory_print function also can take two card_to_flip's, so now the user can flip two at a time, and that's why the main memory game loop loops twice at a time. My goal for tomorrow is to have the memory game have a win/lose state. I also want to print the row and column numbers when printing the grid, so it can be more user-friendly.

Nov 9: Today, I focused on being user-friendly. First, I simplied the user prompts to now be straight to the point. Now it prompts the user with "Card #[1 or 2] row?" and "Card #[1 or 2] column?" Also, yesterday I guess I never noticed that card_to_flip2 didn't work properly. There just wasn't an if statement to print it in the memory_print function. I fixed that by adding the if statement, and now it works perfectly. I also achieved my goal from yesterday of printing the row and column numbers. This was a bit of a challenge for the nested for loops, but I was able to figure it out. Instead of looping five times, the outer for loop (i) now loops six times, but there is now a if statement in inside the nest checking if it's the first time i has looped. If yes, it only prints the column numbers. If no, it just print the memory grid as normal. The row numbers were slightly simpler to implement. Inside the outer for loop and outside the inner for loop (it's before the inner for loop) is a if statement that checks if i is greater than 0. If it is, it prints the row number. Next, also to be more user friendly, I decided to change the row and column numbers to start at one instead of zero. I feel like starting at one is easier to visualize, and it's more convenient when you're typing numbers on a keyboard. Last but not least, I added and implemented the create_memory_deck function. I decided that a normal deck of cards wouldn't cut it for this game, so I need to make a custom deck of cards. The create_memory_deck takes in a [25][2] integer matrix, returns void, and is very similar to the create_deck function. It has a set of nested for loops that work to initialize the deck matrix. Since the memory grid has an odd number of spaces, at the end of the create_memory function, there is a couple of lines that manually initialize the last element of the matrix. The only difference is the actual deck. The memory deck is just 1-12 (except the last element) and 1 and 2 as the "suits." Because the create_deck and create_memory_deck functions are so similar, I think it would be a good idea to just merge them in the future. Currently, the create_memory_deck function is implemented just as a demo because it doesn't shuffle or print yet. If I were to merge the two functions, I would also need to make the shuffle_deck and print_deck functions compatible with the new memory deck type. That's exactly my goal for tomorrow: I want to merge these two functions together and make all of the related functions work with memory decks.